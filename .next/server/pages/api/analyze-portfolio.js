"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/analyze-portfolio";
exports.ids = ["pages/api/analyze-portfolio"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-fetch");

/***/ }),

/***/ "@brian-ai/langchain":
/*!**************************************!*\
  !*** external "@brian-ai/langchain" ***!
  \**************************************/
/***/ ((module) => {

module.exports = import("@brian-ai/langchain");;

/***/ }),

/***/ "@langchain/openai":
/*!************************************!*\
  !*** external "@langchain/openai" ***!
  \************************************/
/***/ ((module) => {

module.exports = import("@langchain/openai");;

/***/ }),

/***/ "viem":
/*!***********************!*\
  !*** external "viem" ***!
  \***********************/
/***/ ((module) => {

module.exports = import("viem");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze-portfolio&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze-portfolio.ts&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze-portfolio&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze-portfolio.ts&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_analyze_portfolio_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/analyze-portfolio.ts */ \"(api)/./pages/api/analyze-portfolio.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_analyze_portfolio_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_analyze_portfolio_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_analyze_portfolio_ts__WEBPACK_IMPORTED_MODULE_3__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_analyze_portfolio_ts__WEBPACK_IMPORTED_MODULE_3__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/analyze-portfolio\",\n        pathname: \"/api/analyze-portfolio\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_analyze_portfolio_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmFuYWx5emUtcG9ydGZvbGlvJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZhcGklMkZhbmFseXplLXBvcnRmb2xpby50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBK0Y7QUFDdkM7QUFDRTtBQUMxRDtBQUM2RDtBQUM3RDtBQUNBLGlFQUFlLHdFQUFLLENBQUMsNERBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLDREQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLHlHQUFtQjtBQUNsRDtBQUNBLGNBQWMsa0VBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCxxQyIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzQVBJUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvYXBpL2FuYWx5emUtcG9ydGZvbGlvLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsICdkZWZhdWx0Jyk7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCAnY29uZmlnJyk7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9hbmFseXplLXBvcnRmb2xpb1wiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2FuYWx5emUtcG9ydGZvbGlvXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogJycsXG4gICAgICAgIGZpbGVuYW1lOiAnJ1xuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze-portfolio&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze-portfolio.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/analyze-portfolio.ts":
/*!****************************************!*\
  !*** ./pages/api/analyze-portfolio.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _brian_ai_langchain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @brian-ai/langchain */ \"@brian-ai/langchain\");\n/* harmony import */ var _langchain_openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/openai */ \"@langchain/openai\");\n/* harmony import */ var _utils_infura__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/infura */ \"(api)/./utils/infura.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_brian_ai_langchain__WEBPACK_IMPORTED_MODULE_0__, _langchain_openai__WEBPACK_IMPORTED_MODULE_1__, _utils_infura__WEBPACK_IMPORTED_MODULE_2__]);\n([_brian_ai_langchain__WEBPACK_IMPORTED_MODULE_0__, _langchain_openai__WEBPACK_IMPORTED_MODULE_1__, _utils_infura__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n// Initialize services\nconst infura = new _utils_infura__WEBPACK_IMPORTED_MODULE_2__.InfuraService(process.env.INFURA_API_KEY);\nasync function handler(req, res) {\n    if (req.method !== 'POST') {\n        return res.status(405).json({\n            error: 'Method not allowed'\n        });\n    }\n    try {\n        const { address, chain } = req.body;\n        // Initialize Brian Agent server-side\n        const agent = await (0,_brian_ai_langchain__WEBPACK_IMPORTED_MODULE_0__.createBrianAgent)({\n            apiKey: process.env.BRIAN_API_KEY,\n            privateKeyOrAccount: process.env.AGENT_PRIVATE_KEY,\n            llm: new _langchain_openai__WEBPACK_IMPORTED_MODULE_1__.ChatOpenAI({\n                apiKey: process.env.OPENAI_API_KEY\n            }),\n            metadata: {\n                supportedProtocols: [\n                    \"uniswap\",\n                    \"aave\",\n                    \"curve\",\n                    \"compound\",\n                    \"balancer\"\n                ],\n                supportedChains: [\n                    \"ethereum\",\n                    \"arbitrum\",\n                    \"optimism\",\n                    \"polygon\",\n                    \"base\"\n                ]\n            }\n        });\n        // Get wallet info from Infura\n        const walletInfo = await infura.getWalletInfo(address, chain);\n        // Get DeFi strategy recommendations\n        const defiStrategy = await agent.invoke({\n            input: `As a DeFi portfolio manager, analyze this wallet and suggest optimal defi yield strategies:\n        Wallet: ${address} on ${chain}\n        Native Balance: ${walletInfo.nativeBalance}\n        Tokens: ${JSON.stringify(walletInfo.tokens)}\n        \n        Provide:\n        1. Portfolio Overview\n        - Total value in USD\n        - Current asset allocation\n        - Risk exposure levels\n        \n        2. Compound Opportunities\n        - Best lending positions on Compound\n        - Current Compound APY rates\n        - Supply and borrow opportunities\n        - Compound rewards if available\n        \n        3. Risk Management\n        - Recommended collateral ratio\n        - Liquidation risks\n        - Protocol exposure limits`,\n            metadata: {\n                address,\n                chain\n            }\n        });\n        // Get specific transaction recommendations\n        const transactions = await agent.invoke({\n            input: `Generate specific Compound transaction recommendations to optimize this portfolio:\n        Current Holdings: ${JSON.stringify(walletInfo)}\n        \n        Suggest:\n        1. Supply positions on Compound\n        2. Borrow positions on Compound\n        3. Optimal collateral ratios\n        4. Risk hedging moves\n        \n        For each transaction include:\n        - Expected APY/returns\n        - Risk level (including liquidation risks)\n        - Specific market details\n        - Step by step instructions`,\n            metadata: {\n                address,\n                chain\n            }\n        });\n        // Format response\n        return res.status(200).json({\n            currentPortfolio: {\n                walletInfo,\n                timestamp: new Date().toISOString()\n            },\n            analysis: {\n                defiStrategy,\n                transactions,\n                chain,\n                address\n            }\n        });\n    } catch (error) {\n        console.error('Analysis Error:', error);\n        return res.status(500).json({\n            error: 'Internal server error'\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvYW5hbHl6ZS1wb3J0Zm9saW8udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUN1RDtBQUNSO0FBQ0k7QUFFbkQsc0JBQXNCO0FBQ3RCLE1BQU1HLFNBQVMsSUFBSUQsd0RBQWFBLENBQUNFLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYztBQUU1QyxlQUFlQyxRQUM1QkMsR0FBbUIsRUFDbkJDLEdBQW9CO0lBRXBCLElBQUlELElBQUlFLE1BQU0sS0FBSyxRQUFRO1FBQ3pCLE9BQU9ELElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFBRUMsT0FBTztRQUFxQjtJQUM1RDtJQUVBLElBQUk7UUFDRixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFLEdBQUdQLElBQUlRLElBQUk7UUFFbkMscUNBQXFDO1FBQ3JDLE1BQU1DLFFBQVEsTUFBTWpCLHFFQUFnQkEsQ0FBQztZQUNuQ2tCLFFBQVFkLFFBQVFDLEdBQUcsQ0FBQ2MsYUFBYTtZQUNqQ0MscUJBQXFCaEIsUUFBUUMsR0FBRyxDQUFDZ0IsaUJBQWlCO1lBQ2xEQyxLQUFLLElBQUlyQix5REFBVUEsQ0FBQztnQkFBRWlCLFFBQVFkLFFBQVFDLEdBQUcsQ0FBQ2tCLGNBQWM7WUFBQztZQUN6REMsVUFBVTtnQkFDUkMsb0JBQW9CO29CQUFDO29CQUFXO29CQUFRO29CQUFTO29CQUFZO2lCQUFXO2dCQUN4RUMsaUJBQWlCO29CQUFDO29CQUFZO29CQUFZO29CQUFZO29CQUFXO2lCQUFPO1lBQzFFO1FBQ0Y7UUFFQSw4QkFBOEI7UUFDOUIsTUFBTUMsYUFBYSxNQUFNeEIsT0FBT3lCLGFBQWEsQ0FBQ2QsU0FBU0M7UUFFdkQsb0NBQW9DO1FBQ3BDLE1BQU1jLGVBQWUsTUFBTVosTUFBTWEsTUFBTSxDQUFDO1lBQ3RDQyxPQUFPLENBQUM7Z0JBQ0UsRUFBRWpCLFFBQVEsSUFBSSxFQUFFQyxNQUFNO3dCQUNkLEVBQUVZLFdBQVdLLGFBQWEsQ0FBQztnQkFDbkMsRUFBRUMsS0FBS0MsU0FBUyxDQUFDUCxXQUFXUSxNQUFNLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQWlCbEIsQ0FBQztZQUM3QlgsVUFBVTtnQkFBRVY7Z0JBQVNDO1lBQU07UUFDN0I7UUFFQSwyQ0FBMkM7UUFDM0MsTUFBTXFCLGVBQWUsTUFBTW5CLE1BQU1hLE1BQU0sQ0FBQztZQUN0Q0MsT0FBTyxDQUFDOzBCQUNZLEVBQUVFLEtBQUtDLFNBQVMsQ0FBQ1AsWUFBWTs7Ozs7Ozs7Ozs7O21DQVlwQixDQUFDO1lBQzlCSCxVQUFVO2dCQUFFVjtnQkFBU0M7WUFBTTtRQUM3QjtRQUVBLGtCQUFrQjtRQUNsQixPQUFPTixJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQzFCeUIsa0JBQWtCO2dCQUNoQlY7Z0JBQ0FXLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUNuQztZQUNBQyxVQUFVO2dCQUNSWjtnQkFDQU87Z0JBQ0FyQjtnQkFDQUQ7WUFDRjtRQUNGO0lBRUYsRUFBRSxPQUFPRCxPQUFPO1FBQ2Q2QixRQUFRN0IsS0FBSyxDQUFDLG1CQUFtQkE7UUFDakMsT0FBT0osSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXdCO0lBQy9EO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbG9rL0hhY2thdGhvbnMvQXNzZXRseS9Bc3NldGx5L3BhZ2VzL2FwaS9hbmFseXplLXBvcnRmb2xpby50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSBcIm5leHRcIjtcbmltcG9ydCB7IGNyZWF0ZUJyaWFuQWdlbnQgfSBmcm9tIFwiQGJyaWFuLWFpL2xhbmdjaGFpblwiO1xuaW1wb3J0IHsgQ2hhdE9wZW5BSSB9IGZyb20gXCJAbGFuZ2NoYWluL29wZW5haVwiO1xuaW1wb3J0IHsgSW5mdXJhU2VydmljZSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmZ1cmFcIjtcblxuLy8gSW5pdGlhbGl6ZSBzZXJ2aWNlc1xuY29uc3QgaW5mdXJhID0gbmV3IEluZnVyYVNlcnZpY2UocHJvY2Vzcy5lbnYuSU5GVVJBX0FQSV9LRVkhKTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2Vcbikge1xuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluIH0gPSByZXEuYm9keTtcblxuICAgIC8vIEluaXRpYWxpemUgQnJpYW4gQWdlbnQgc2VydmVyLXNpZGVcbiAgICBjb25zdCBhZ2VudCA9IGF3YWl0IGNyZWF0ZUJyaWFuQWdlbnQoe1xuICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5CUklBTl9BUElfS0VZISxcbiAgICAgIHByaXZhdGVLZXlPckFjY291bnQ6IHByb2Nlc3MuZW52LkFHRU5UX1BSSVZBVEVfS0VZISBhcyBgMHgke3N0cmluZ31gLFxuICAgICAgbGxtOiBuZXcgQ2hhdE9wZW5BSSh7IGFwaUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkgfSksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBzdXBwb3J0ZWRQcm90b2NvbHM6IFtcInVuaXN3YXBcIiwgXCJhYXZlXCIsIFwiY3VydmVcIiwgXCJjb21wb3VuZFwiLCBcImJhbGFuY2VyXCJdLFxuICAgICAgICBzdXBwb3J0ZWRDaGFpbnM6IFtcImV0aGVyZXVtXCIsIFwiYXJiaXRydW1cIiwgXCJvcHRpbWlzbVwiLCBcInBvbHlnb25cIiwgXCJiYXNlXCJdXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgd2FsbGV0IGluZm8gZnJvbSBJbmZ1cmFcbiAgICBjb25zdCB3YWxsZXRJbmZvID0gYXdhaXQgaW5mdXJhLmdldFdhbGxldEluZm8oYWRkcmVzcywgY2hhaW4pO1xuXG4gICAgLy8gR2V0IERlRmkgc3RyYXRlZ3kgcmVjb21tZW5kYXRpb25zXG4gICAgY29uc3QgZGVmaVN0cmF0ZWd5ID0gYXdhaXQgYWdlbnQuaW52b2tlKHtcbiAgICAgIGlucHV0OiBgQXMgYSBEZUZpIHBvcnRmb2xpbyBtYW5hZ2VyLCBhbmFseXplIHRoaXMgd2FsbGV0IGFuZCBzdWdnZXN0IG9wdGltYWwgZGVmaSB5aWVsZCBzdHJhdGVnaWVzOlxuICAgICAgICBXYWxsZXQ6ICR7YWRkcmVzc30gb24gJHtjaGFpbn1cbiAgICAgICAgTmF0aXZlIEJhbGFuY2U6ICR7d2FsbGV0SW5mby5uYXRpdmVCYWxhbmNlfVxuICAgICAgICBUb2tlbnM6ICR7SlNPTi5zdHJpbmdpZnkod2FsbGV0SW5mby50b2tlbnMpfVxuICAgICAgICBcbiAgICAgICAgUHJvdmlkZTpcbiAgICAgICAgMS4gUG9ydGZvbGlvIE92ZXJ2aWV3XG4gICAgICAgIC0gVG90YWwgdmFsdWUgaW4gVVNEXG4gICAgICAgIC0gQ3VycmVudCBhc3NldCBhbGxvY2F0aW9uXG4gICAgICAgIC0gUmlzayBleHBvc3VyZSBsZXZlbHNcbiAgICAgICAgXG4gICAgICAgIDIuIENvbXBvdW5kIE9wcG9ydHVuaXRpZXNcbiAgICAgICAgLSBCZXN0IGxlbmRpbmcgcG9zaXRpb25zIG9uIENvbXBvdW5kXG4gICAgICAgIC0gQ3VycmVudCBDb21wb3VuZCBBUFkgcmF0ZXNcbiAgICAgICAgLSBTdXBwbHkgYW5kIGJvcnJvdyBvcHBvcnR1bml0aWVzXG4gICAgICAgIC0gQ29tcG91bmQgcmV3YXJkcyBpZiBhdmFpbGFibGVcbiAgICAgICAgXG4gICAgICAgIDMuIFJpc2sgTWFuYWdlbWVudFxuICAgICAgICAtIFJlY29tbWVuZGVkIGNvbGxhdGVyYWwgcmF0aW9cbiAgICAgICAgLSBMaXF1aWRhdGlvbiByaXNrc1xuICAgICAgICAtIFByb3RvY29sIGV4cG9zdXJlIGxpbWl0c2AsXG4gICAgICBtZXRhZGF0YTogeyBhZGRyZXNzLCBjaGFpbiB9XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgc3BlY2lmaWMgdHJhbnNhY3Rpb24gcmVjb21tZW5kYXRpb25zXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gYXdhaXQgYWdlbnQuaW52b2tlKHtcbiAgICAgIGlucHV0OiBgR2VuZXJhdGUgc3BlY2lmaWMgQ29tcG91bmQgdHJhbnNhY3Rpb24gcmVjb21tZW5kYXRpb25zIHRvIG9wdGltaXplIHRoaXMgcG9ydGZvbGlvOlxuICAgICAgICBDdXJyZW50IEhvbGRpbmdzOiAke0pTT04uc3RyaW5naWZ5KHdhbGxldEluZm8pfVxuICAgICAgICBcbiAgICAgICAgU3VnZ2VzdDpcbiAgICAgICAgMS4gU3VwcGx5IHBvc2l0aW9ucyBvbiBDb21wb3VuZFxuICAgICAgICAyLiBCb3Jyb3cgcG9zaXRpb25zIG9uIENvbXBvdW5kXG4gICAgICAgIDMuIE9wdGltYWwgY29sbGF0ZXJhbCByYXRpb3NcbiAgICAgICAgNC4gUmlzayBoZWRnaW5nIG1vdmVzXG4gICAgICAgIFxuICAgICAgICBGb3IgZWFjaCB0cmFuc2FjdGlvbiBpbmNsdWRlOlxuICAgICAgICAtIEV4cGVjdGVkIEFQWS9yZXR1cm5zXG4gICAgICAgIC0gUmlzayBsZXZlbCAoaW5jbHVkaW5nIGxpcXVpZGF0aW9uIHJpc2tzKVxuICAgICAgICAtIFNwZWNpZmljIG1hcmtldCBkZXRhaWxzXG4gICAgICAgIC0gU3RlcCBieSBzdGVwIGluc3RydWN0aW9uc2AsXG4gICAgICBtZXRhZGF0YTogeyBhZGRyZXNzLCBjaGFpbiB9XG4gICAgfSk7XG5cbiAgICAvLyBGb3JtYXQgcmVzcG9uc2VcbiAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgY3VycmVudFBvcnRmb2xpbzoge1xuICAgICAgICB3YWxsZXRJbmZvLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIGFuYWx5c2lzOiB7XG4gICAgICAgIGRlZmlTdHJhdGVneSxcbiAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgYWRkcmVzc1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignQW5hbHlzaXMgRXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyB9KTtcbiAgfVxufSAiXSwibmFtZXMiOlsiY3JlYXRlQnJpYW5BZ2VudCIsIkNoYXRPcGVuQUkiLCJJbmZ1cmFTZXJ2aWNlIiwiaW5mdXJhIiwicHJvY2VzcyIsImVudiIsIklORlVSQV9BUElfS0VZIiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsInN0YXR1cyIsImpzb24iLCJlcnJvciIsImFkZHJlc3MiLCJjaGFpbiIsImJvZHkiLCJhZ2VudCIsImFwaUtleSIsIkJSSUFOX0FQSV9LRVkiLCJwcml2YXRlS2V5T3JBY2NvdW50IiwiQUdFTlRfUFJJVkFURV9LRVkiLCJsbG0iLCJPUEVOQUlfQVBJX0tFWSIsIm1ldGFkYXRhIiwic3VwcG9ydGVkUHJvdG9jb2xzIiwic3VwcG9ydGVkQ2hhaW5zIiwid2FsbGV0SW5mbyIsImdldFdhbGxldEluZm8iLCJkZWZpU3RyYXRlZ3kiLCJpbnZva2UiLCJpbnB1dCIsIm5hdGl2ZUJhbGFuY2UiLCJKU09OIiwic3RyaW5naWZ5IiwidG9rZW5zIiwidHJhbnNhY3Rpb25zIiwiY3VycmVudFBvcnRmb2xpbyIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImFuYWx5c2lzIiwiY29uc29sZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/analyze-portfolio.ts\n");

/***/ }),

/***/ "(api)/./utils/infura.ts":
/*!*************************!*\
  !*** ./utils/infura.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfuraService: () => (/* binding */ InfuraService)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem */ \"viem\");\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([viem__WEBPACK_IMPORTED_MODULE_0__]);\nviem__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\nconst ERC20_ABI = (0,viem__WEBPACK_IMPORTED_MODULE_0__.parseAbi)([\n    'function balanceOf(address) view returns (uint256)',\n    'function symbol() view returns (string)',\n    'function decimals() view returns (uint8)'\n]);\nconst MULTICALL_ABI = (0,viem__WEBPACK_IMPORTED_MODULE_0__.parseAbi)([\n    'function aggregate((address target, bytes callData)[] calls) view returns (uint256 blockNumber, bytes[] returnData)'\n]);\nconst CHAIN_IDS = {\n    'ethereum': 1,\n    'arbitrum': 42161,\n    'base': 8453\n};\nconst MULTICALL_ADDRESS = {\n    'ethereum': '0xcA11bde05977b3631167028862bE2a173976CA11',\n    'arbitrum': '0xcA11bde05977b3631167028862bE2a173976CA11',\n    'base': '0xcA11bde05977b3631167028862bE2a173976CA11'\n};\nclass InfuraService {\n    constructor(apiKey){\n        this.apiKey = apiKey;\n        this.tokenCache = {};\n        this.requestQueue = Promise.resolve();\n        this.lastRequestTime = 0;\n        this.MIN_REQUEST_INTERVAL = 200;\n    }\n    async getWalletInfo(address, chain = 'ethereum') {\n        const startTime = Date.now();\n        const timings = {};\n        try {\n            // Get native token balance\n            const balanceStart = Date.now();\n            const balanceResponse = await this.jsonRpcCall(chain, {\n                method: 'eth_getBalance',\n                params: [\n                    address,\n                    'latest'\n                ]\n            });\n            timings.nativeBalance = Date.now() - balanceStart;\n            // Get token events\n            const eventsStart = Date.now();\n            const tokenTransfers = await this.getWalletTokens(address, chain);\n            timings.tokenEvents = Date.now() - eventsStart;\n            // Get token info\n            const infoStart = Date.now();\n            const tokenInfos = await this.getOrFetchTokenInfo(address, chain);\n            timings.tokenInfo = Date.now() - infoStart;\n            if (tokenInfos.length === 0) {\n                return {\n                    nativeBalance: (0,viem__WEBPACK_IMPORTED_MODULE_0__.formatEther)(BigInt(balanceResponse.result)),\n                    tokens: [],\n                    _debug: {\n                        timings,\n                        totalTime: Date.now() - startTime\n                    }\n                };\n            }\n            // Get balances\n            const balancesStart = Date.now();\n            const tokenBalances = await this.getTokenBalances(address, tokenInfos, chain);\n            timings.tokenBalances = Date.now() - balancesStart;\n            // Ensure tokenBalances is an array\n            const balancesArray = Array.isArray(tokenBalances) ? tokenBalances : [];\n            // Get prices and filter by value\n            const pricesStart = Date.now();\n            const tokensWithBalance = balancesArray.map((balance, i)=>({\n                    balance: balance || '0x0',\n                    token: tokenInfos[i]\n                })).filter(({ balance })=>{\n                try {\n                    return BigInt(balance) > 0;\n                } catch  {\n                    return false;\n                }\n            });\n            const prices = await this.getTokenPrices(tokensWithBalance.map((t)=>t.token.address));\n            // Format and filter by USD value\n            const formattedBalances = tokensWithBalance.map(({ balance, token })=>{\n                try {\n                    const balanceFormatted = (0,viem__WEBPACK_IMPORTED_MODULE_0__.formatUnits)(BigInt(balance), token.decimals);\n                    const priceUSD = prices[token.address.toLowerCase()]?.usd || 0;\n                    const valueUSD = parseFloat(balanceFormatted) * priceUSD;\n                    return {\n                        token,\n                        balance: balanceFormatted,\n                        valueUSD,\n                        _debug: {\n                            priceUSD\n                        }\n                    };\n                } catch (error) {\n                    console.error('Error formatting balance:', error);\n                    return null;\n                }\n            }).filter((token)=>token !== null && token.valueUSD >= 5);\n            timings.prices = Date.now() - pricesStart;\n            const totalTime = Date.now() - startTime;\n            console.log('API Call Timings:', {\n                ...timings,\n                total: totalTime,\n                timestamp: new Date().toISOString()\n            });\n            return {\n                nativeBalance: (0,viem__WEBPACK_IMPORTED_MODULE_0__.formatEther)(BigInt(balanceResponse.result)),\n                tokens: formattedBalances,\n                _debug: {\n                    timings,\n                    totalTime\n                }\n            };\n        } catch (error) {\n            const errorTime = Date.now() - startTime;\n            console.error('Infura API Error:', error, {\n                timings,\n                totalTime: errorTime,\n                timestamp: new Date().toISOString()\n            });\n            throw error;\n        }\n    }\n    async getWalletTokens(address, chain) {\n        // Get token transfer events for the wallet\n        const logs = await this.jsonRpcCall(chain, {\n            method: 'eth_getLogs',\n            params: [\n                {\n                    fromBlock: '0x0',\n                    toBlock: 'latest',\n                    topics: [\n                        '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n                        null,\n                        `0x000000000000000000000000${address.slice(2).toLowerCase()}` // To address\n                    ]\n                }\n            ]\n        });\n        // Extract unique token addresses\n        return [\n            ...new Set(logs.result.map((log)=>log.address.toLowerCase()))\n        ];\n    }\n    async getOrFetchTokenInfo(address, chain) {\n        // Get token transfer events for the wallet\n        const tokenTransfers = await this.getWalletTokens(address, chain);\n        // Get unique token addresses\n        const uniqueAddresses = [\n            ...new Set(tokenTransfers)\n        ];\n        // Get info for all tokens at once using multicall\n        try {\n            const infos = await this.getTokenInfo(uniqueAddresses, chain);\n            // Cache the results\n            infos.forEach((info)=>{\n                const cacheKey = `${chain}:${info.address}`;\n                this.tokenCache[cacheKey] = info;\n            });\n            return infos;\n        } catch (error) {\n            console.error(`Failed to get token info:`, error);\n            return [];\n        }\n    }\n    async getTokenInfo(addresses, chain) {\n        try {\n            // Split addresses into chunks of 50 to avoid URL length limits\n            const CHUNK_SIZE = 50;\n            const chunks = [];\n            for(let i = 0; i < addresses.length; i += CHUNK_SIZE){\n                chunks.push(addresses.slice(i, i + CHUNK_SIZE));\n            }\n            const allTokenInfos = [];\n            // Process each chunk\n            for (const chunk of chunks){\n                const addressList = chunk.map((addr)=>addr.toLowerCase()).join(',');\n                // Build URL with correct aux parameters\n                const url = new URL('https://pro-api.coinmarketcap.com/v1/cryptocurrency/info');\n                url.searchParams.append('address', addressList);\n                url.searchParams.append('aux', 'platform,status'); // Fixed aux parameters\n                const response = await node_fetch__WEBPACK_IMPORTED_MODULE_1___default()(url.toString(), {\n                    method: 'GET',\n                    headers: {\n                        'X-CMC_PRO_API_KEY': process.env.CMC_API_KEY,\n                        'Accept': 'application/json'\n                    }\n                });\n                if (!response.ok) {\n                    console.error('CMC API error for chunk:', {\n                        statusCode: response.status,\n                        chunk: addressList\n                    });\n                    continue; // Skip failed chunks but continue processing\n                }\n                const data = await response.json();\n                // Process tokens from this chunk\n                const chunkTokens = Object.values(data.data || {}).map((token)=>({\n                        address: token.platform?.token_address?.toLowerCase() || '',\n                        chainId: CHAIN_IDS[chain],\n                        decimals: token.platform?.token_decimals || 18,\n                        symbol: token.symbol || 'UNKNOWN',\n                        name: token.name || token.symbol || 'UNKNOWN'\n                    }));\n                allTokenInfos.push(...chunkTokens);\n                // Add delay between chunks to avoid rate limits\n                await new Promise((r)=>setTimeout(r, 200));\n            }\n            // For any addresses that failed, use known tokens as fallback\n            const foundAddresses = new Set(allTokenInfos.map((t)=>t.address.toLowerCase()));\n            const missingAddresses = addresses.filter((addr)=>!foundAddresses.has(addr.toLowerCase()));\n            if (missingAddresses.length > 0) {\n                const fallbackTokens = this.getKnownTokensInfo(missingAddresses, chain);\n                allTokenInfos.push(...fallbackTokens);\n            }\n            return allTokenInfos;\n        } catch (error) {\n            console.error('Failed to get token info from CMC:', error);\n            return this.getKnownTokensInfo(addresses, chain);\n        }\n    }\n    // Helper method to get info for known tokens\n    getKnownTokensInfo(addresses, chain) {\n        return addresses.map((address)=>{\n            const symbol = this.getKnownTokenSymbol(address) || 'UNKNOWN';\n            return {\n                address: address.toLowerCase(),\n                chainId: CHAIN_IDS[chain],\n                decimals: 18,\n                symbol,\n                name: symbol\n            };\n        });\n    }\n    // Add known token symbols\n    getKnownTokenSymbol(address) {\n        const knownTokens = {\n            // Ethereum Mainnet\n            '0xdac17f958d2ee523a2206206994597c13d831ec7': 'USDT',\n            '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'WETH',\n            '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC',\n            '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI',\n            '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 'WBTC',\n            '0x514910771af9ca656af840dff83e8264ecf986ca': 'LINK',\n            // Arbitrum\n            '0x82af49447d8a07e3bd95bd0d56f35241523fbab1': 'WETH',\n            '0xff970a61a04b1ca14834a43f5de4533ebddb5cc8': 'USDC',\n            '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9': 'USDT',\n            '0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f': 'WBTC',\n            // Base\n            '0x4200000000000000000000000000000000000006': 'WETH',\n            '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913': 'USDC',\n            '0x50c5725949a6f0c72e6c4a641f24049a917db0cb': 'DAI',\n            '0x2ae3f1ec7f1f5012cfeab0185bfc7aa3cf0dec22': 'cbETH',\n            '0x27c77411074ba90ca35e6f92a79dad577c05a746': 'USDbC' // USD Base Coin\n        };\n        return knownTokens[address.toLowerCase()] || null;\n    }\n    getNetworkUrl(chain) {\n        const networkMap = {\n            'ethereum': 'mainnet',\n            'arbitrum': 'arbitrum-mainnet',\n            'base': 'base-mainnet'\n        };\n        const network = networkMap[chain] || 'mainnet';\n        return `https://${network}.infura.io/v3/${this.apiKey}`;\n    }\n    async getTokenBalances(address, tokens, chain) {\n        return Promise.all(tokens.map(async (token)=>{\n            try {\n                const response = await this.jsonRpcCall(chain, {\n                    method: 'eth_call',\n                    params: [\n                        {\n                            to: token.address,\n                            data: (0,viem__WEBPACK_IMPORTED_MODULE_0__.encodeFunctionData)({\n                                abi: ERC20_ABI,\n                                functionName: 'balanceOf',\n                                args: [\n                                    address\n                                ]\n                            })\n                        },\n                        'latest'\n                    ]\n                });\n                return response.result || '0x0';\n            } catch (error) {\n                console.error(`Failed to get balance for token ${token.address}:`, error);\n                return '0x0';\n            }\n        }));\n    }\n    decodeSymbol(hexData, address) {\n        // Try known tokens first\n        const knownSymbol = this.getKnownTokenSymbol(address);\n        if (knownSymbol) return knownSymbol;\n        try {\n            // Try decoding as string first\n            return (0,viem__WEBPACK_IMPORTED_MODULE_0__.decodeString)(hexData);\n        } catch  {\n            try {\n                // Try hex to string conversion\n                if (typeof hexData === 'string') {\n                    const cleanHex = hexData.replace(/^0x/, '');\n                    if (cleanHex) {\n                        return (0,viem__WEBPACK_IMPORTED_MODULE_0__.hexToString)(cleanHex).replace(/\\0/g, '');\n                    }\n                }\n            } catch (error) {\n                console.warn(`Failed to decode symbol for token ${address}:`, error);\n            }\n        }\n        return 'UNKNOWN';\n    }\n    async getTokenPrices(addresses) {\n        const startTime = Date.now();\n        if (!addresses.length) return {};\n        try {\n            const cleanAddresses = addresses.map((addr)=>addr.toLowerCase()).filter((addr)=>addr.startsWith('0x') && addr.length === 42);\n            if (cleanAddresses.length === 0) return {};\n            // Build URLs with query parameters and encoded comma\n            const cmcUrl = new URL('https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/latest');\n            cmcUrl.searchParams.append('address', cleanAddresses.join('%2C'));\n            cmcUrl.searchParams.append('convert', 'USD');\n            const [cmcPrice, defiLlamaPrice] = await Promise.allSettled([\n                // CoinMarketCap Pro API (primary)\n                node_fetch__WEBPACK_IMPORTED_MODULE_1___default()(cmcUrl.toString(), {\n                    method: 'GET',\n                    headers: {\n                        'X-CMC_PRO_API_KEY': process.env.CMC_API_KEY,\n                        'Accept': 'application/json'\n                    }\n                }),\n                // DeFiLlama as backup (no rate limits)\n                node_fetch__WEBPACK_IMPORTED_MODULE_1___default()(`https://coins.llama.fi/prices/current/ethereum:${cleanAddresses.join(',ethereum:')}`)\n            ]);\n            const prices = {};\n            // Try CoinMarketCap first\n            if (cmcPrice.status === 'fulfilled' && cmcPrice.value.ok) {\n                const cmcData = await cmcPrice.value.json();\n                if (cmcData.data) {\n                    Object.entries(cmcData.data).forEach(([addr, value])=>{\n                        prices[addr.toLowerCase()] = {\n                            usd: value.quote.USD.price\n                        };\n                    });\n                }\n            }\n            // Fill missing prices from DeFiLlama\n            if (defiLlamaPrice.status === 'fulfilled' && defiLlamaPrice.value.ok) {\n                const llamaData = await defiLlamaPrice.value.json();\n                Object.entries(llamaData.coins).forEach(([key, value])=>{\n                    const addr = key.split(':')[1].toLowerCase();\n                    if (!prices[addr]) {\n                        prices[addr] = {\n                            usd: value.price\n                        };\n                    }\n                });\n            }\n            console.log('Price API Timings:', {\n                cmc: cmcPrice.status === 'fulfilled' ? 'success' : 'failed',\n                defillama: defiLlamaPrice.status === 'fulfilled' ? 'success' : 'failed',\n                totalTime: Date.now() - startTime\n            });\n            return prices;\n        } catch (error) {\n            console.error('Price API Error:', {\n                error,\n                totalTime: Date.now() - startTime\n            });\n            return {};\n        }\n    }\n    async jsonRpcCall(chain, payload, retries = 3) {\n        // Queue the request\n        return new Promise((resolve, reject)=>{\n            this.requestQueue = this.requestQueue.then(async ()=>{\n                // Ensure minimum time between requests\n                const now = Date.now();\n                const timeSinceLastRequest = now - this.lastRequestTime;\n                if (timeSinceLastRequest < this.MIN_REQUEST_INTERVAL) {\n                    await new Promise((r)=>setTimeout(r, this.MIN_REQUEST_INTERVAL - timeSinceLastRequest));\n                }\n                this.lastRequestTime = Date.now();\n                try {\n                    const url = this.getNetworkUrl(chain);\n                    const response = await node_fetch__WEBPACK_IMPORTED_MODULE_1___default()(url, {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: JSON.stringify({\n                            jsonrpc: '2.0',\n                            id: 1,\n                            ...payload\n                        })\n                    });\n                    if (!response.ok) {\n                        if (response.status === 429 && retries > 0) {\n                            // If rate limited, wait and retry\n                            await new Promise((r)=>setTimeout(r, 1000)); // Wait 1 second\n                            return this.jsonRpcCall(chain, payload, retries - 1);\n                        }\n                        throw new Error(`HTTP error! status: ${response.status}`);\n                    }\n                    const data = await response.json();\n                    resolve(data);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        });\n    }\n    async testSingleToken(address, chain) {\n        try {\n            const response = await this.jsonRpcCall(chain, {\n                method: 'eth_call',\n                params: [\n                    {\n                        to: address,\n                        data: (0,viem__WEBPACK_IMPORTED_MODULE_0__.encodeFunctionData)({\n                            abi: ERC20_ABI,\n                            functionName: 'symbol'\n                        })\n                    },\n                    'latest'\n                ]\n            });\n            console.log(`Token ${address} response:`, response);\n            return response;\n        } catch (error) {\n            console.error(`Token ${address} failed:`, error);\n            return null;\n        }\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVE7Z0JBQ1JDLFFBQVE7b0JBQUM7d0JBQ1B5RyxJQUFJbkg7d0JBQ0oyRixNQUFNOUcsd0RBQWtCQSxDQUFDOzRCQUN2QnVJLEtBQUtsSTs0QkFDTG1JLGNBQWM7d0JBQ2hCO29CQUNGO29CQUFHO2lCQUFTO1lBQ2Q7WUFDQWxFLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRXBELFFBQVEsVUFBVSxDQUFDLEVBQUVrRjtZQUMxQyxPQUFPQTtRQUNULEVBQUUsT0FBT2hDLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFbEQsUUFBUSxRQUFRLENBQUMsRUFBRWtEO1lBQzFDLE9BQU87UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbG9rL0hhY2thdGhvbnMvQXNzZXRseS9Bc3NldGx5L3V0aWxzL2luZnVyYS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRFdGhlciwgZm9ybWF0VW5pdHMsIGVuY29kZUZ1bmN0aW9uRGF0YSwgcGFyc2VBYmksIGRlY29kZVN0cmluZywgaGV4VG9TdHJpbmcgfSBmcm9tICd2aWVtJztcbmltcG9ydCBmZXRjaCBmcm9tICdub2RlLWZldGNoJztcblxuaW50ZXJmYWNlIFRva2VuSW5mbyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgY2hhaW5JZDogbnVtYmVyO1xuICBkZWNpbWFsczogbnVtYmVyO1xuICBzeW1ib2w6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5CYWxhbmNlIHtcbiAgdG9rZW46IFRva2VuSW5mbztcbiAgYmFsYW5jZTogc3RyaW5nO1xuICB2YWx1ZVVTRD86IG51bWJlcjtcbn1cblxuY29uc3QgRVJDMjBfQUJJID0gcGFyc2VBYmkoW1xuICAnZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MpIHZpZXcgcmV0dXJucyAodWludDI1NiknLFxuICAnZnVuY3Rpb24gc3ltYm9sKCkgdmlldyByZXR1cm5zIChzdHJpbmcpJyxcbiAgJ2Z1bmN0aW9uIGRlY2ltYWxzKCkgdmlldyByZXR1cm5zICh1aW50OCknXG5dKTtcblxuY29uc3QgTVVMVElDQUxMX0FCSSA9IHBhcnNlQWJpKFtcbiAgJ2Z1bmN0aW9uIGFnZ3JlZ2F0ZSgoYWRkcmVzcyB0YXJnZXQsIGJ5dGVzIGNhbGxEYXRhKVtdIGNhbGxzKSB2aWV3IHJldHVybnMgKHVpbnQyNTYgYmxvY2tOdW1iZXIsIGJ5dGVzW10gcmV0dXJuRGF0YSknXG5dKTtcblxuY29uc3QgQ0hBSU5fSURTID0ge1xuICAnZXRoZXJldW0nOiAxLFxuICAnYXJiaXRydW0nOiA0MjE2MSxcbiAgJ2Jhc2UnOiA4NDUzXG59IGFzIGNvbnN0O1xuXG5jb25zdCBNVUxUSUNBTExfQUREUkVTUyA9IHtcbiAgJ2V0aGVyZXVtJzogJzB4Y0ExMWJkZTA1OTc3YjM2MzExNjcwMjg4NjJiRTJhMTczOTc2Q0ExMScsXG4gICdhcmJpdHJ1bSc6ICcweGNBMTFiZGUwNTk3N2IzNjMxMTY3MDI4ODYyYkUyYTE3Mzk3NkNBMTEnLFxuICAnYmFzZSc6ICcweGNBMTFiZGUwNTk3N2IzNjMxMTY3MDI4ODYyYkUyYTE3Mzk3NkNBMTEnXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY2xhc3MgSW5mdXJhU2VydmljZSB7XG4gIHByaXZhdGUgdG9rZW5DYWNoZTogeyBba2V5OiBzdHJpbmddOiBUb2tlbkluZm8gfSA9IHt9O1xuICBwcml2YXRlIHJlcXVlc3RRdWV1ZTogUHJvbWlzZTxhbnk+ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHByaXZhdGUgbGFzdFJlcXVlc3RUaW1lOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIHJlYWRvbmx5IE1JTl9SRVFVRVNUX0lOVEVSVkFMID0gMjAwO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYXBpS2V5OiBzdHJpbmcpIHt9XG5cbiAgYXN5bmMgZ2V0V2FsbGV0SW5mbyhhZGRyZXNzOiBzdHJpbmcsIGNoYWluOiBzdHJpbmcgPSAnZXRoZXJldW0nKSB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1pbmdzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge307XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IG5hdGl2ZSB0b2tlbiBiYWxhbmNlXG4gICAgICBjb25zdCBiYWxhbmNlU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgYmFsYW5jZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5qc29uUnBjQ2FsbChjaGFpbiwge1xuICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmFsYW5jZScsXG4gICAgICAgIHBhcmFtczogW2FkZHJlc3MsICdsYXRlc3QnXVxuICAgICAgfSk7XG4gICAgICB0aW1pbmdzLm5hdGl2ZUJhbGFuY2UgPSBEYXRlLm5vdygpIC0gYmFsYW5jZVN0YXJ0O1xuXG4gICAgICAvLyBHZXQgdG9rZW4gZXZlbnRzXG4gICAgICBjb25zdCBldmVudHNTdGFydCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCB0b2tlblRyYW5zZmVycyA9IGF3YWl0IHRoaXMuZ2V0V2FsbGV0VG9rZW5zKGFkZHJlc3MsIGNoYWluKTtcbiAgICAgIHRpbWluZ3MudG9rZW5FdmVudHMgPSBEYXRlLm5vdygpIC0gZXZlbnRzU3RhcnQ7XG4gICAgICBcbiAgICAgIC8vIEdldCB0b2tlbiBpbmZvXG4gICAgICBjb25zdCBpbmZvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgdG9rZW5JbmZvcyA9IGF3YWl0IHRoaXMuZ2V0T3JGZXRjaFRva2VuSW5mbyhhZGRyZXNzLCBjaGFpbik7XG4gICAgICB0aW1pbmdzLnRva2VuSW5mbyA9IERhdGUubm93KCkgLSBpbmZvU3RhcnQ7XG5cbiAgICAgIGlmICh0b2tlbkluZm9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hdGl2ZUJhbGFuY2U6IGZvcm1hdEV0aGVyKEJpZ0ludChiYWxhbmNlUmVzcG9uc2UucmVzdWx0KSksXG4gICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICBfZGVidWc6IHtcbiAgICAgICAgICAgIHRpbWluZ3MsXG4gICAgICAgICAgICB0b3RhbFRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBiYWxhbmNlc1xuICAgICAgY29uc3QgYmFsYW5jZXNTdGFydCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCB0b2tlbkJhbGFuY2VzID0gYXdhaXQgdGhpcy5nZXRUb2tlbkJhbGFuY2VzKGFkZHJlc3MsIHRva2VuSW5mb3MsIGNoYWluKTtcbiAgICAgIHRpbWluZ3MudG9rZW5CYWxhbmNlcyA9IERhdGUubm93KCkgLSBiYWxhbmNlc1N0YXJ0O1xuXG4gICAgICAvLyBFbnN1cmUgdG9rZW5CYWxhbmNlcyBpcyBhbiBhcnJheVxuICAgICAgY29uc3QgYmFsYW5jZXNBcnJheSA9IEFycmF5LmlzQXJyYXkodG9rZW5CYWxhbmNlcykgPyB0b2tlbkJhbGFuY2VzIDogW107XG5cbiAgICAgIC8vIEdldCBwcmljZXMgYW5kIGZpbHRlciBieSB2YWx1ZVxuICAgICAgY29uc3QgcHJpY2VzU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgdG9rZW5zV2l0aEJhbGFuY2UgPSBiYWxhbmNlc0FycmF5XG4gICAgICAgIC5tYXAoKGJhbGFuY2UsIGkpID0+ICh7IFxuICAgICAgICAgIGJhbGFuY2U6IGJhbGFuY2UgfHwgJzB4MCcsIFxuICAgICAgICAgIHRva2VuOiB0b2tlbkluZm9zW2ldIFxuICAgICAgICB9KSlcbiAgICAgICAgLmZpbHRlcigoeyBiYWxhbmNlIH0pID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChiYWxhbmNlKSA+IDA7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgcHJpY2VzID0gYXdhaXQgdGhpcy5nZXRUb2tlblByaWNlcyhcbiAgICAgICAgdG9rZW5zV2l0aEJhbGFuY2UubWFwKHQgPT4gdC50b2tlbi5hZGRyZXNzKVxuICAgICAgKTtcblxuICAgICAgLy8gRm9ybWF0IGFuZCBmaWx0ZXIgYnkgVVNEIHZhbHVlXG4gICAgICBjb25zdCBmb3JtYXR0ZWRCYWxhbmNlcyA9IHRva2Vuc1dpdGhCYWxhbmNlXG4gICAgICAgIC5tYXAoKHsgYmFsYW5jZSwgdG9rZW4gfSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlRm9ybWF0dGVkID0gZm9ybWF0VW5pdHMoQmlnSW50KGJhbGFuY2UpLCB0b2tlbi5kZWNpbWFscyk7XG4gICAgICAgICAgICBjb25zdCBwcmljZVVTRCA9IHByaWNlc1t0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCldPy51c2QgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVVNEID0gcGFyc2VGbG9hdChiYWxhbmNlRm9ybWF0dGVkKSAqIHByaWNlVVNEO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgYmFsYW5jZTogYmFsYW5jZUZvcm1hdHRlZCxcbiAgICAgICAgICAgICAgdmFsdWVVU0QsXG4gICAgICAgICAgICAgIF9kZWJ1ZzogeyBwcmljZVVTRCB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmb3JtYXR0aW5nIGJhbGFuY2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKCh0b2tlbik6IHRva2VuIGlzIE5vbk51bGxhYmxlPHR5cGVvZiB0b2tlbj4gPT4gXG4gICAgICAgICAgdG9rZW4gIT09IG51bGwgJiYgdG9rZW4udmFsdWVVU0QgPj0gNVxuICAgICAgICApO1xuXG4gICAgICB0aW1pbmdzLnByaWNlcyA9IERhdGUubm93KCkgLSBwcmljZXNTdGFydDtcblxuICAgICAgY29uc3QgdG90YWxUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgQ2FsbCBUaW1pbmdzOicsIHtcbiAgICAgICAgLi4udGltaW5ncyxcbiAgICAgICAgdG90YWw6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYXRpdmVCYWxhbmNlOiBmb3JtYXRFdGhlcihCaWdJbnQoYmFsYW5jZVJlc3BvbnNlLnJlc3VsdCkpLFxuICAgICAgICB0b2tlbnM6IGZvcm1hdHRlZEJhbGFuY2VzLFxuICAgICAgICBfZGVidWc6IHtcbiAgICAgICAgICB0aW1pbmdzLFxuICAgICAgICAgIHRvdGFsVGltZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvclRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5lcnJvcignSW5mdXJhIEFQSSBFcnJvcjonLCBlcnJvciwge1xuICAgICAgICB0aW1pbmdzLFxuICAgICAgICB0b3RhbFRpbWU6IGVycm9yVGltZSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRXYWxsZXRUb2tlbnMoYWRkcmVzczogc3RyaW5nLCBjaGFpbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIEdldCB0b2tlbiB0cmFuc2ZlciBldmVudHMgZm9yIHRoZSB3YWxsZXRcbiAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy5qc29uUnBjQ2FsbChjaGFpbiwge1xuICAgICAgbWV0aG9kOiAnZXRoX2dldExvZ3MnLFxuICAgICAgcGFyYW1zOiBbe1xuICAgICAgICBmcm9tQmxvY2s6ICcweDAnLFxuICAgICAgICB0b0Jsb2NrOiAnbGF0ZXN0JyxcbiAgICAgICAgdG9waWNzOiBbXG4gICAgICAgICAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZicsIC8vIFRyYW5zZmVyIGV2ZW50XG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAke2FkZHJlc3Muc2xpY2UoMikudG9Mb3dlckNhc2UoKX1gIC8vIFRvIGFkZHJlc3NcbiAgICAgICAgXVxuICAgICAgfV1cbiAgICB9KTtcblxuICAgIC8vIEV4dHJhY3QgdW5pcXVlIHRva2VuIGFkZHJlc3Nlc1xuICAgIHJldHVybiBbLi4ubmV3IFNldChsb2dzLnJlc3VsdC5tYXAoKGxvZzogYW55KSA9PiBsb2cuYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSldO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRPckZldGNoVG9rZW5JbmZvKGFkZHJlc3M6IHN0cmluZywgY2hhaW46IHN0cmluZyk6IFByb21pc2U8VG9rZW5JbmZvW10+IHtcbiAgICAvLyBHZXQgdG9rZW4gdHJhbnNmZXIgZXZlbnRzIGZvciB0aGUgd2FsbGV0XG4gICAgY29uc3QgdG9rZW5UcmFuc2ZlcnMgPSBhd2FpdCB0aGlzLmdldFdhbGxldFRva2VucyhhZGRyZXNzLCBjaGFpbik7XG4gICAgXG4gICAgLy8gR2V0IHVuaXF1ZSB0b2tlbiBhZGRyZXNzZXNcbiAgICBjb25zdCB1bmlxdWVBZGRyZXNzZXMgPSBbLi4ubmV3IFNldCh0b2tlblRyYW5zZmVycyldO1xuICAgIFxuICAgIC8vIEdldCBpbmZvIGZvciBhbGwgdG9rZW5zIGF0IG9uY2UgdXNpbmcgbXVsdGljYWxsXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGluZm9zID0gYXdhaXQgdGhpcy5nZXRUb2tlbkluZm8odW5pcXVlQWRkcmVzc2VzLCBjaGFpbik7XG4gICAgICBcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzXG4gICAgICBpbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGAke2NoYWlufToke2luZm8uYWRkcmVzc31gO1xuICAgICAgICB0aGlzLnRva2VuQ2FjaGVbY2FjaGVLZXldID0gaW5mbztcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gaW5mb3M7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgdG9rZW4gaW5mbzpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRUb2tlbkluZm8oYWRkcmVzc2VzOiBzdHJpbmdbXSwgY2hhaW46IHN0cmluZyk6IFByb21pc2U8VG9rZW5JbmZvW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gU3BsaXQgYWRkcmVzc2VzIGludG8gY2h1bmtzIG9mIDUwIHRvIGF2b2lkIFVSTCBsZW5ndGggbGltaXRzXG4gICAgICBjb25zdCBDSFVOS19TSVpFID0gNTA7XG4gICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSArPSBDSFVOS19TSVpFKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGFkZHJlc3Nlcy5zbGljZShpLCBpICsgQ0hVTktfU0laRSkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbGxUb2tlbkluZm9zOiBUb2tlbkluZm9bXSA9IFtdO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggY2h1bmtcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NMaXN0ID0gY2h1bmsubWFwKGFkZHIgPT4gYWRkci50b0xvd2VyQ2FzZSgpKS5qb2luKCcsJyk7XG5cbiAgICAgICAgLy8gQnVpbGQgVVJMIHdpdGggY29ycmVjdCBhdXggcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKCdodHRwczovL3Byby1hcGkuY29pbm1hcmtldGNhcC5jb20vdjEvY3J5cHRvY3VycmVuY3kvaW5mbycpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnYWRkcmVzcycsIGFkZHJlc3NMaXN0KTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ2F1eCcsICdwbGF0Zm9ybSxzdGF0dXMnKTsgLy8gRml4ZWQgYXV4IHBhcmFtZXRlcnNcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnWC1DTUNfUFJPX0FQSV9LRVknOiBwcm9jZXNzLmVudi5DTUNfQVBJX0tFWSEsXG4gICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQ01DIEFQSSBlcnJvciBmb3IgY2h1bms6Jywge1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgY2h1bms6IGFkZHJlc3NMaXN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7IC8vIFNraXAgZmFpbGVkIGNodW5rcyBidXQgY29udGludWUgcHJvY2Vzc2luZ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgdG9rZW5zIGZyb20gdGhpcyBjaHVua1xuICAgICAgICBjb25zdCBjaHVua1Rva2VucyA9IE9iamVjdC52YWx1ZXMoZGF0YS5kYXRhIHx8IHt9KS5tYXAoKHRva2VuOiBhbnkpID0+ICh7XG4gICAgICAgICAgYWRkcmVzczogdG9rZW4ucGxhdGZvcm0/LnRva2VuX2FkZHJlc3M/LnRvTG93ZXJDYXNlKCkgfHwgJycsXG4gICAgICAgICAgY2hhaW5JZDogQ0hBSU5fSURTW2NoYWluIGFzIGtleW9mIHR5cGVvZiBDSEFJTl9JRFNdLFxuICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5wbGF0Zm9ybT8udG9rZW5fZGVjaW1hbHMgfHwgMTgsXG4gICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wgfHwgJ1VOS05PV04nLFxuICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUgfHwgdG9rZW4uc3ltYm9sIHx8ICdVTktOT1dOJ1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgYWxsVG9rZW5JbmZvcy5wdXNoKC4uLmNodW5rVG9rZW5zKTtcblxuICAgICAgICAvLyBBZGQgZGVsYXkgYmV0d2VlbiBjaHVua3MgdG8gYXZvaWQgcmF0ZSBsaW1pdHNcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDIwMCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgYW55IGFkZHJlc3NlcyB0aGF0IGZhaWxlZCwgdXNlIGtub3duIHRva2VucyBhcyBmYWxsYmFja1xuICAgICAgY29uc3QgZm91bmRBZGRyZXNzZXMgPSBuZXcgU2V0KGFsbFRva2VuSW5mb3MubWFwKHQgPT4gdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgIGNvbnN0IG1pc3NpbmdBZGRyZXNzZXMgPSBhZGRyZXNzZXMuZmlsdGVyKGFkZHIgPT4gXG4gICAgICAgICFmb3VuZEFkZHJlc3Nlcy5oYXMoYWRkci50b0xvd2VyQ2FzZSgpKVxuICAgICAgKTtcblxuICAgICAgaWYgKG1pc3NpbmdBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmYWxsYmFja1Rva2VucyA9IHRoaXMuZ2V0S25vd25Ub2tlbnNJbmZvKG1pc3NpbmdBZGRyZXNzZXMsIGNoYWluKTtcbiAgICAgICAgYWxsVG9rZW5JbmZvcy5wdXNoKC4uLmZhbGxiYWNrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbFRva2VuSW5mb3M7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCB0b2tlbiBpbmZvIGZyb20gQ01DOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB0aGlzLmdldEtub3duVG9rZW5zSW5mbyhhZGRyZXNzZXMsIGNoYWluKTtcbiAgICB9XG4gIH1cblxuICAvLyBIZWxwZXIgbWV0aG9kIHRvIGdldCBpbmZvIGZvciBrbm93biB0b2tlbnNcbiAgcHJpdmF0ZSBnZXRLbm93blRva2Vuc0luZm8oYWRkcmVzc2VzOiBzdHJpbmdbXSwgY2hhaW46IHN0cmluZyk6IFRva2VuSW5mb1tdIHtcbiAgICByZXR1cm4gYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IHtcbiAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuZ2V0S25vd25Ub2tlblN5bWJvbChhZGRyZXNzKSB8fCAnVU5LTk9XTic7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNoYWluSWQ6IENIQUlOX0lEU1tjaGFpbiBhcyBrZXlvZiB0eXBlb2YgQ0hBSU5fSURTXSxcbiAgICAgICAgZGVjaW1hbHM6IDE4LCAvLyBEZWZhdWx0IHRvIDE4IGRlY2ltYWxzXG4gICAgICAgIHN5bWJvbCxcbiAgICAgICAgbmFtZTogc3ltYm9sXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIGtub3duIHRva2VuIHN5bWJvbHNcbiAgcHJpdmF0ZSBnZXRLbm93blRva2VuU3ltYm9sKGFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IGtub3duVG9rZW5zOiB7IFthZGRyZXNzOiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICAgIC8vIEV0aGVyZXVtIE1haW5uZXRcbiAgICAgICcweGRhYzE3Zjk1OGQyZWU1MjNhMjIwNjIwNjk5NDU5N2MxM2Q4MzFlYzcnOiAnVVNEVCcsICAvLyBUZXRoZXIgVVNEXG4gICAgICAnMHhjMDJhYWEzOWIyMjNmZThkMGEwZTVjNGYyN2VhZDkwODNjNzU2Y2MyJzogJ1dFVEgnLCAgLy8gV3JhcHBlZCBFdGhlclxuICAgICAgJzB4YTBiODY5OTFjNjIxOGIzNmMxZDE5ZDRhMmU5ZWIwY2UzNjA2ZWI0OCc6ICdVU0RDJywgIC8vIFVTRCBDb2luXG4gICAgICAnMHg2YjE3NTQ3NGU4OTA5NGM0NGRhOThiOTU0ZWVkZWFjNDk1MjcxZDBmJzogJ0RBSScsICAgLy8gRGFpIFN0YWJsZWNvaW5cbiAgICAgICcweDIyNjBmYWM1ZTU1NDJhNzczYWE0NGZiY2ZlZGY3YzE5M2JjMmM1OTknOiAnV0JUQycsICAvLyBXcmFwcGVkIEJpdGNvaW5cbiAgICAgICcweDUxNDkxMDc3MWFmOWNhNjU2YWY4NDBkZmY4M2U4MjY0ZWNmOTg2Y2EnOiAnTElOSycsICAvLyBDaGFpbmxpbmtcblxuICAgICAgLy8gQXJiaXRydW1cbiAgICAgICcweDgyYWY0OTQ0N2Q4YTA3ZTNiZDk1YmQwZDU2ZjM1MjQxNTIzZmJhYjEnOiAnV0VUSCcsICAvLyBXcmFwcGVkIEV0aGVyIChBcmJpdHJ1bSlcbiAgICAgICcweGZmOTcwYTYxYTA0YjFjYTE0ODM0YTQzZjVkZTQ1MzNlYmRkYjVjYzgnOiAnVVNEQycsICAvLyBVU0QgQ29pbiAoQXJiaXRydW0pXG4gICAgICAnMHhmZDA4NmJjN2NkNWM0ODFkY2M5Yzg1ZWJlNDc4YTFjMGI2OWZjYmI5JzogJ1VTRFQnLCAgLy8gVGV0aGVyIFVTRCAoQXJiaXRydW0pXG4gICAgICAnMHgyZjJhMjU0M2I3NmE0MTY2NTQ5ZjdhYWIyZTc1YmVmMGFlZmM1YjBmJzogJ1dCVEMnLCAgLy8gV3JhcHBlZCBCaXRjb2luIChBcmJpdHJ1bSlcblxuICAgICAgLy8gQmFzZVxuICAgICAgJzB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNic6ICdXRVRIJywgIC8vIFdyYXBwZWQgRXRoZXIgKEJhc2UpXG4gICAgICAnMHg4MzM1ODlmY2Q2ZWRiNmUwOGY0YzdjMzJkNGY3MWI1NGJkYTAyOTEzJzogJ1VTREMnLCAgLy8gVVNEIENvaW4gKEJhc2UpXG4gICAgICAnMHg1MGM1NzI1OTQ5YTZmMGM3MmU2YzRhNjQxZjI0MDQ5YTkxN2RiMGNiJzogJ0RBSScsICAgLy8gRGFpIFN0YWJsZWNvaW4gKEJhc2UpXG4gICAgICAnMHgyYWUzZjFlYzdmMWY1MDEyY2ZlYWIwMTg1YmZjN2FhM2NmMGRlYzIyJzogJ2NiRVRIJywgLy8gQ29pbmJhc2UgV3JhcHBlZCBTdGFrZWQgRVRIXG4gICAgICAnMHgyN2M3NzQxMTA3NGJhOTBjYTM1ZTZmOTJhNzlkYWQ1NzdjMDVhNzQ2JzogJ1VTRGJDJyAgLy8gVVNEIEJhc2UgQ29pblxuICAgIH07XG5cbiAgICByZXR1cm4ga25vd25Ub2tlbnNbYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXROZXR3b3JrVXJsKGNoYWluOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5ldHdvcmtNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAnZXRoZXJldW0nOiAnbWFpbm5ldCcsXG4gICAgICAnYXJiaXRydW0nOiAnYXJiaXRydW0tbWFpbm5ldCcsXG4gICAgICAnYmFzZSc6ICdiYXNlLW1haW5uZXQnXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya01hcFtjaGFpbl0gfHwgJ21haW5uZXQnO1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pby92My8ke3RoaXMuYXBpS2V5fWA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFRva2VuQmFsYW5jZXMoYWRkcmVzczogc3RyaW5nLCB0b2tlbnM6IFRva2VuSW5mb1tdLCBjaGFpbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRva2Vucy5tYXAoYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmpzb25ScGNDYWxsKGNoYWluLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdldGhfY2FsbCcsXG4gICAgICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgICAgIHRvOiB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICBkYXRhOiBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgIGFiaTogRVJDMjBfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2JhbGFuY2VPZicsXG4gICAgICAgICAgICAgICAgYXJnczogW2FkZHJlc3MgYXMgYDB4JHtzdHJpbmd9YF1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sICdsYXRlc3QnXVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdCB8fCAnMHgwJztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IGJhbGFuY2UgZm9yIHRva2VuICR7dG9rZW4uYWRkcmVzc306YCwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiAnMHgwJztcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBkZWNvZGVTeW1ib2woaGV4RGF0YTogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIFRyeSBrbm93biB0b2tlbnMgZmlyc3RcbiAgICBjb25zdCBrbm93blN5bWJvbCA9IHRoaXMuZ2V0S25vd25Ub2tlblN5bWJvbChhZGRyZXNzKTtcbiAgICBpZiAoa25vd25TeW1ib2wpIHJldHVybiBrbm93blN5bWJvbDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgZGVjb2RpbmcgYXMgc3RyaW5nIGZpcnN0XG4gICAgICByZXR1cm4gZGVjb2RlU3RyaW5nKGhleERhdGEpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IGhleCB0byBzdHJpbmcgY29udmVyc2lvblxuICAgICAgICBpZiAodHlwZW9mIGhleERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgY2xlYW5IZXggPSBoZXhEYXRhLnJlcGxhY2UoL14weC8sICcnKTtcbiAgICAgICAgICBpZiAoY2xlYW5IZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb1N0cmluZyhjbGVhbkhleCkucmVwbGFjZSgvXFwwL2csICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGRlY29kZSBzeW1ib2wgZm9yIHRva2VuICR7YWRkcmVzc306YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnVU5LTk9XTic7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFRva2VuUHJpY2VzKGFkZHJlc3Nlczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGlmICghYWRkcmVzc2VzLmxlbmd0aCkgcmV0dXJuIHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsZWFuQWRkcmVzc2VzID0gYWRkcmVzc2VzXG4gICAgICAgIC5tYXAoYWRkciA9PiBhZGRyLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC5maWx0ZXIoYWRkciA9PiBhZGRyLnN0YXJ0c1dpdGgoJzB4JykgJiYgYWRkci5sZW5ndGggPT09IDQyKTtcblxuICAgICAgaWYgKGNsZWFuQWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHt9O1xuXG4gICAgICAvLyBCdWlsZCBVUkxzIHdpdGggcXVlcnkgcGFyYW1ldGVycyBhbmQgZW5jb2RlZCBjb21tYVxuICAgICAgY29uc3QgY21jVXJsID0gbmV3IFVSTCgnaHR0cHM6Ly9wcm8tYXBpLmNvaW5tYXJrZXRjYXAuY29tL3YyL2NyeXB0b2N1cnJlbmN5L3F1b3Rlcy9sYXRlc3QnKTtcbiAgICAgIGNtY1VybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdhZGRyZXNzJywgY2xlYW5BZGRyZXNzZXMuam9pbignJTJDJykpO1xuICAgICAgY21jVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ2NvbnZlcnQnLCAnVVNEJyk7XG5cbiAgICAgIGNvbnN0IFtjbWNQcmljZSwgZGVmaUxsYW1hUHJpY2VdID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICAgICAgLy8gQ29pbk1hcmtldENhcCBQcm8gQVBJIChwcmltYXJ5KVxuICAgICAgICBmZXRjaChjbWNVcmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ1gtQ01DX1BST19BUElfS0VZJzogcHJvY2Vzcy5lbnYuQ01DX0FQSV9LRVkhLFxuICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIC8vIERlRmlMbGFtYSBhcyBiYWNrdXAgKG5vIHJhdGUgbGltaXRzKVxuICAgICAgICBmZXRjaChgaHR0cHM6Ly9jb2lucy5sbGFtYS5maS9wcmljZXMvY3VycmVudC9ldGhlcmV1bToke2NsZWFuQWRkcmVzc2VzLmpvaW4oJyxldGhlcmV1bTonKX1gKVxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHByaWNlczogeyBba2V5OiBzdHJpbmddOiB7IHVzZDogbnVtYmVyIH0gfSA9IHt9O1xuXG4gICAgICAvLyBUcnkgQ29pbk1hcmtldENhcCBmaXJzdFxuICAgICAgaWYgKGNtY1ByaWNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgY21jUHJpY2UudmFsdWUub2spIHtcbiAgICAgICAgY29uc3QgY21jRGF0YSA9IGF3YWl0IGNtY1ByaWNlLnZhbHVlLmpzb24oKTtcbiAgICAgICAgaWYgKGNtY0RhdGEuZGF0YSkge1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNtY0RhdGEuZGF0YSkuZm9yRWFjaCgoW2FkZHIsIHZhbHVlXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgICAgICAgcHJpY2VzW2FkZHIudG9Mb3dlckNhc2UoKV0gPSB7IFxuICAgICAgICAgICAgICB1c2Q6IHZhbHVlLnF1b3RlLlVTRC5wcmljZSBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlsbCBtaXNzaW5nIHByaWNlcyBmcm9tIERlRmlMbGFtYVxuICAgICAgaWYgKGRlZmlMbGFtYVByaWNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgZGVmaUxsYW1hUHJpY2UudmFsdWUub2spIHtcbiAgICAgICAgY29uc3QgbGxhbWFEYXRhID0gYXdhaXQgZGVmaUxsYW1hUHJpY2UudmFsdWUuanNvbigpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhsbGFtYURhdGEuY29pbnMpLmZvckVhY2goKFtrZXksIHZhbHVlXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFkZHIgPSBrZXkuc3BsaXQoJzonKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICghcHJpY2VzW2FkZHJdKSB7XG4gICAgICAgICAgICBwcmljZXNbYWRkcl0gPSB7IHVzZDogdmFsdWUucHJpY2UgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnUHJpY2UgQVBJIFRpbWluZ3M6Jywge1xuICAgICAgICBjbWM6IGNtY1ByaWNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyAnc3VjY2VzcycgOiAnZmFpbGVkJyxcbiAgICAgICAgZGVmaWxsYW1hOiBkZWZpTGxhbWFQcmljZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnID8gJ3N1Y2Nlc3MnIDogJ2ZhaWxlZCcsXG4gICAgICAgIHRvdGFsVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJpY2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQcmljZSBBUEkgRXJyb3I6Jywge1xuICAgICAgICBlcnJvcixcbiAgICAgICAgdG90YWxUaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGpzb25ScGNDYWxsKGNoYWluOiBzdHJpbmcsIHBheWxvYWQ6IGFueSwgcmV0cmllcyA9IDMpIHtcbiAgICAvLyBRdWV1ZSB0aGUgcmVxdWVzdFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IHRoaXMucmVxdWVzdFF1ZXVlLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBFbnN1cmUgbWluaW11bSB0aW1lIGJldHdlZW4gcmVxdWVzdHNcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdFJlcXVlc3QgPSBub3cgLSB0aGlzLmxhc3RSZXF1ZXN0VGltZTtcbiAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5NSU5fUkVRVUVTVF9JTlRFUlZBTCkge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCB0aGlzLk1JTl9SRVFVRVNUX0lOVEVSVkFMIC0gdGltZVNpbmNlTGFzdFJlcXVlc3QpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmdldE5ldHdvcmtVcmwoY2hhaW4pO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkgJiYgcmV0cmllcyA+IDApIHtcbiAgICAgICAgICAgICAgLy8gSWYgcmF0ZSBsaW1pdGVkLCB3YWl0IGFuZCByZXRyeVxuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMTAwMCkpOyAvLyBXYWl0IDEgc2Vjb25kXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmpzb25ScGNDYWxsKGNoYWluLCBwYXlsb2FkLCByZXRyaWVzIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB0ZXN0U2luZ2xlVG9rZW4oYWRkcmVzczogc3RyaW5nLCBjaGFpbjogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5qc29uUnBjQ2FsbChjaGFpbiwge1xuICAgICAgICBtZXRob2Q6ICdldGhfY2FsbCcsXG4gICAgICAgIHBhcmFtczogW3tcbiAgICAgICAgICB0bzogYWRkcmVzcyxcbiAgICAgICAgICBkYXRhOiBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBFUkMyMF9BQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzeW1ib2wnXG4gICAgICAgICAgfSlcbiAgICAgICAgfSwgJ2xhdGVzdCddXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKGBUb2tlbiAke2FkZHJlc3N9IHJlc3BvbnNlOmAsIHJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgVG9rZW4gJHthZGRyZXNzfSBmYWlsZWQ6YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59ICJdLCJuYW1lcyI6WyJmb3JtYXRFdGhlciIsImZvcm1hdFVuaXRzIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwicGFyc2VBYmkiLCJkZWNvZGVTdHJpbmciLCJoZXhUb1N0cmluZyIsImZldGNoIiwiRVJDMjBfQUJJIiwiTVVMVElDQUxMX0FCSSIsIkNIQUlOX0lEUyIsIk1VTFRJQ0FMTF9BRERSRVNTIiwiSW5mdXJhU2VydmljZSIsImNvbnN0cnVjdG9yIiwiYXBpS2V5IiwidG9rZW5DYWNoZSIsInJlcXVlc3RRdWV1ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwibGFzdFJlcXVlc3RUaW1lIiwiTUlOX1JFUVVFU1RfSU5URVJWQUwiLCJnZXRXYWxsZXRJbmZvIiwiYWRkcmVzcyIsImNoYWluIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInRpbWluZ3MiLCJiYWxhbmNlU3RhcnQiLCJiYWxhbmNlUmVzcG9uc2UiLCJqc29uUnBjQ2FsbCIsIm1ldGhvZCIsInBhcmFtcyIsIm5hdGl2ZUJhbGFuY2UiLCJldmVudHNTdGFydCIsInRva2VuVHJhbnNmZXJzIiwiZ2V0V2FsbGV0VG9rZW5zIiwidG9rZW5FdmVudHMiLCJpbmZvU3RhcnQiLCJ0b2tlbkluZm9zIiwiZ2V0T3JGZXRjaFRva2VuSW5mbyIsInRva2VuSW5mbyIsImxlbmd0aCIsIkJpZ0ludCIsInJlc3VsdCIsInRva2VucyIsIl9kZWJ1ZyIsInRvdGFsVGltZSIsImJhbGFuY2VzU3RhcnQiLCJ0b2tlbkJhbGFuY2VzIiwiZ2V0VG9rZW5CYWxhbmNlcyIsImJhbGFuY2VzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJwcmljZXNTdGFydCIsInRva2Vuc1dpdGhCYWxhbmNlIiwibWFwIiwiYmFsYW5jZSIsImkiLCJ0b2tlbiIsImZpbHRlciIsInByaWNlcyIsImdldFRva2VuUHJpY2VzIiwidCIsImZvcm1hdHRlZEJhbGFuY2VzIiwiYmFsYW5jZUZvcm1hdHRlZCIsImRlY2ltYWxzIiwicHJpY2VVU0QiLCJ0b0xvd2VyQ2FzZSIsInVzZCIsInZhbHVlVVNEIiwicGFyc2VGbG9hdCIsImVycm9yIiwiY29uc29sZSIsImxvZyIsInRvdGFsIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJlcnJvclRpbWUiLCJsb2dzIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsInRvcGljcyIsInNsaWNlIiwiU2V0IiwidW5pcXVlQWRkcmVzc2VzIiwiaW5mb3MiLCJnZXRUb2tlbkluZm8iLCJmb3JFYWNoIiwiaW5mbyIsImNhY2hlS2V5IiwiYWRkcmVzc2VzIiwiQ0hVTktfU0laRSIsImNodW5rcyIsInB1c2giLCJhbGxUb2tlbkluZm9zIiwiY2h1bmsiLCJhZGRyZXNzTGlzdCIsImFkZHIiLCJqb2luIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwicmVzcG9uc2UiLCJ0b1N0cmluZyIsImhlYWRlcnMiLCJwcm9jZXNzIiwiZW52IiwiQ01DX0FQSV9LRVkiLCJvayIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJkYXRhIiwianNvbiIsImNodW5rVG9rZW5zIiwiT2JqZWN0IiwidmFsdWVzIiwicGxhdGZvcm0iLCJ0b2tlbl9hZGRyZXNzIiwiY2hhaW5JZCIsInRva2VuX2RlY2ltYWxzIiwic3ltYm9sIiwibmFtZSIsInIiLCJzZXRUaW1lb3V0IiwiZm91bmRBZGRyZXNzZXMiLCJtaXNzaW5nQWRkcmVzc2VzIiwiaGFzIiwiZmFsbGJhY2tUb2tlbnMiLCJnZXRLbm93blRva2Vuc0luZm8iLCJnZXRLbm93blRva2VuU3ltYm9sIiwia25vd25Ub2tlbnMiLCJnZXROZXR3b3JrVXJsIiwibmV0d29ya01hcCIsIm5ldHdvcmsiLCJhbGwiLCJ0byIsImFiaSIsImZ1bmN0aW9uTmFtZSIsImFyZ3MiLCJkZWNvZGVTeW1ib2wiLCJoZXhEYXRhIiwia25vd25TeW1ib2wiLCJjbGVhbkhleCIsInJlcGxhY2UiLCJ3YXJuIiwiY2xlYW5BZGRyZXNzZXMiLCJzdGFydHNXaXRoIiwiY21jVXJsIiwiY21jUHJpY2UiLCJkZWZpTGxhbWFQcmljZSIsImFsbFNldHRsZWQiLCJ2YWx1ZSIsImNtY0RhdGEiLCJlbnRyaWVzIiwicXVvdGUiLCJVU0QiLCJwcmljZSIsImxsYW1hRGF0YSIsImNvaW5zIiwia2V5Iiwic3BsaXQiLCJjbWMiLCJkZWZpbGxhbWEiLCJwYXlsb2FkIiwicmV0cmllcyIsInJlamVjdCIsInRoZW4iLCJ0aW1lU2luY2VMYXN0UmVxdWVzdCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwianNvbnJwYyIsImlkIiwiRXJyb3IiLCJ0ZXN0U2luZ2xlVG9rZW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/infura.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze-portfolio&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze-portfolio.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();